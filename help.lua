--[[ Lua "help" module
allows setting docstrings for Lua objects,
and optionally forwarding help calls
to other subsystems that have introspective
information about objects (Luabind, osgLua
included)
]]

--[[ Original Author: Ryan Pavlik <rpavlik@acm.org> <abiryan@ryand.net>
Copyright 2011 Iowa State University.
Distributed under the Boost Software License, Version 1.0.

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
]]

local mt = {}
help = setmetatable({}, mt)
local docstrings = setmetatable({}, {__mode = "kv"})
local helpExtensions = {}

local function tableExtend(dest, src)
	local applied = {}
	if type(src) ~= "table" then
		src = {src}
	end

	-- Integer keys: add them to the list
	for i, v in ipairs(src) do
		table.insert(dest, v)
		applied[i] = true
	end

	-- non-integer keys: set or append
	for k,v in pairs(src) do
		if not applied[k] then
			if type(dest[k]) == "table" then
				-- if dest is a table, either
				if type(v) == "table" then
					-- recurse
					tableExtend(dest[k], v)
				else
					-- or just append
					table.insert(dest[k], v)
				end
			else
				-- just set if it's not a table
				dest[k] = v
			end
		end
	end

end

function mt:__call(...)
	if arg.n == 0 then
		print("help(obj) - call to learn information about a particular object or value.")
		return
	end
	for i,obj in ipairs(arg) do
		local helpContent = help.lookup(obj)
		local helpHeader
		if i == 1 then
			helpHeader = "Help:\t"
		else
			print("")
			helpHeader = string.format("Help (#%d):\t", i)
		end
		if helpContent then
			print(helpHeader .. help.formatHelp(helpContent))
		else
			print(helpHeader .. "type(obj) = " .. type(obj))
			print("No further help available!")
		end
	end
end

function help.formatHelp(h)
  if type(h) == "string" then
    return h
  elseif type(h) == "table" then
    local keys = {}
    local str = ""
    for i, v in ipairs(h) do
      keys[i] = true
      str = str .. "\n" .. v
    end
    for k,v in pairs(h) do
      if not keys[k] then
        if type(v) == "table" then
          str = string.format("%s\n%s = {", str, k)
          for _, val in ipairs(v) do
            str = str .. "\n\t" .. tostring(val)
          end
          str = str .. "\n}\n"
        else
          str = str .. string.format("\n%s = %s", k, tostring(v))
        end
      end
    end
    return str
  else
    return h
  end
end

function help.lookup(obj)
	if docstrings[obj] then
		 return docstrings[obj]
	end
	for _, v in ipairs(helpExtensions) do
		local helpContent = v(obj)
		if helpContent then
			return helpContent
		end
	end
	return nil
end

function help.docstring(docs)
	local mt = {}
	local function mergeDocs(obj)
		if help.lookup(obj) == nil then
			docstrings[obj] = docs
		else
			local mergedDocs = help.lookup(obj)
			tableExtend(mergedDocs, docs)
			docstrings[obj] = mergedDocs
		end
	end

	-- handle the .. operator for inline documentation
	function mt.__concat(_, obj)
		mergeDocs(obj)
		return obj
	end

	-- handle a call to applyTo() for after-the-fact docs
	local ret = {}
	function ret.applyTo(obj)
		mergeDocs(obj)
		return obj
	end

	-- Also just let them tack on () to the docstring call.
	function mt:__call(obj)
		mergeDocs(obj)
		return self
	end
	return setmetatable(ret, mt)
end

function help.addHelpExtension(func)
	table.insert(helpExtensions, func)
end


-- Assume that a class_info method means that luabind has been
-- opened in this state and that class_info has been registered
if class_info then
  require("helpLuabind")
end

-- If there's something called osgLua, assume it is osgLua the
-- introspection-based OpenSceneGraph-wrapper
if osgLua then
  require("helpOsgLua")
end

--[[ begin documentation ]]

-- Docstring for the help function
-- because you know somebody will try help(help)
help.docstring{
	[==[
Display as much helpful information as possible about the argument.
There will be more information if you define docstrings for
your objects. Try help(help.docstring) for info.
]==],
	functions = {
		"docstring",
		"lookup",
		"addHelpExtension",
		"formatHelp"
	},

}.applyTo(help)

-- Document help extensions
help.docstring[==[
Add a function to lookup help in other systems, not help.docstring.

Accepts a function that, given a lua object, either returns
a table with data like that passed to help.docstring, or nil
if it doesn't know anything special about the object.
]==].applyTo(help.addHelpExtension)

-- Gets a bit weird here - documentation for help.docstring
help.docstring[==[
Define documentation for an object.

You can pass just a string:
 help.docstring[[
  Help goes here free-form.
 ]]
or provide more structured help:
 help.docstring{
  [[
  Help goes here.
  ]],
  args = {"this", "that", "the other"},
  methods = {"doThis", "doThat", "doOther"}
 }

No particular structure/requirement for the arguments
you pass - just make them useful.

If setting a variable, like
  a = function() code goes here end
you can call
  a = help.docstring[[your docs]] .. function() code goes here end.

If you are documenting some object a "after the fact", you can tack on a call
to .applyTo(yourObj) (or multiple calls!) after help.docstring:
  help.docstring[[your docs]].applyTo(a)
  help.docstring[[your docs]].applyTo(c).applyTo(d)
or even just parentheses for calling:
  help.docstring[[your docs]](a)


Quoting strings are somewhat flexible: see this web page for
the full details: http://www.lua.org/manual/5.1/manual.html#2.1
]==].applyTo(help.docstring)

